{"intents": [
    {
        "points": "1",
        "patterns": ["Erklaeren sie kurz, was das Prinzip der Kapselung besagt."],
        "responses": ["Die Kapselung besagt, dass man Informationen nach außen hin verbirgt, sodass man von außen nicht darauf zugreifen kann.", "Kapselung ist ein Konzept, dass als Ziel hat interne Daten zu verstecken, sodass sie auf diese nicht extern zugegriffen werden kann.", "Durch Kapselung erstellt man eine Schnittstelle, sodass auf manche Funktionen und Daten nicht zugegriffen werden kann.", "Es werden Details der Implementierung vor versteckt, sodass sie von außen nicht einsehbar und benutzbar sind.", "Kapselung ist ein Prinzip aus der objektorientierten Programmierung. Man möchte erreichen, dass Methoden und Klassen vom Nutzer nicht erreicht werden können. Man beschränkt also den Zugriff nach außen und versteckt sie. Man kann somit kontrollieren welche internen Daten sichtbar sind und welche nicht. Es gibt unterschiedliche Sichtbarkeitsstufen: standard, public, protected, private. Bei standard gibt man keine Modifikation an, bei public sind alle Methoden oder Daten der Klasse sichtbar und man kann auf sie zugreifen. Protected lässt nur zu, dass vererbende Klassen Zugriff haben und durch private können die Methoden nur in der Klasse selbst benutzt werden. Man sollte bei der Wahl der Sichtbarkeit darauf achten, dass die Zugänglichkeitsstufe so gering wie möglich ist, damit der Code so sicher wie möglich ist.", "Durch Kapselung möchte man erreichen, dass Methoden und Klassen vom Nutzer nicht erreicht werden können. Man beschränkt also den Zugriff nach außen und versteckt sie. Es gibt unterschiedliche Sichtbarkeitsstufen: standard, public, protected, private", "Durch Kapselung möchte man erreichen, dass Methoden und Klassen vom Nutzer nicht erreicht werden können. Man beschränkt also den Zugriff nach außen und versteckt sie. Es gibt unterschiedliche Sichtbarkeitsstufen: standard, public, secured, private", "Kapslung erlaubt den Zugriff von außen auf Daten und Methoden, sodass man auch wenn man in anderen Klassen agiert immer auf alle anderen Klassen zugreifen kann"]
    },
    {
        "points": "3",
        "patterns": ["Nennen Sie jeweils einen lexikalischen, syntaktischen und (statisch) semantischen Fehler (In der Programmiersprache Java)."],
        "responses": ["Ein lexikalischer Fehler wäre das Fehlen von Klammern bei einer Funktion. Ein syntaktischer Fehler ist zum Beispiel nicht die richtige Anzahl an Parametern zu übergeben und ein semantischer Fehler wäre eine falsche Bedinung in einer IF-Anweisung, sodass das Ergebnis nicht das Gewünschte ist.", "Lexikalisch: Bolean, Syntaktisch: If-Bedingung nicht durch eine Klammer schließen, Semantisch: Nicht auffangen von Fehlern, also keine Fehlerbehandlung.", "Lexikalische Fehler sind Tippfehler, Syntaktischer Fehler sind falsche Verwendung von Datentypen und Semantische Fehler sind allgemein Fehler, die nicht zu dem vom Programmierer gewünschten Ergebnis führen, obwohl der Code ohne Fehler durchläuft.", "Ein lexiklaischer Fehler wäre das Falschschreiben von Schlüsselwörter und ein sematischer wäre es, wenn mehrere Threads nicht synchronisiert werden und auf eine gemeinsame Ressource zugreifen, auf die sie nicht gleichzeitig zugreifen dürfen.", "Syntax: Rückgabetyp falsch. Lexikalisch: ':' statt '/'. Sematisch: Fehler nicht behandelt", "Ein lexikalische Fehler wären zum Beispiel bei Deklarieren einer Variable nicht '=' zu schrieben, sondern '==' oder wenn man Schlüsselwörter falsch schriebt oder statt einer schließenden Klammer zwei verwendet oder nicht ein Semikolon, sondern ein Punkt zum abschließen einer Anweisung verwendet. Die IDE kann diese Fehler meistens sofort erkennen und beheben. Werden die Fehler nicht behoben, dann kann es zu Fehlern beim Aufrufen des Programms führen. Syntaktische Fehler sind zum Beispiel beim Zuweisen das '=' zu vergessen oder wenn man nicht genügend Parameter übergibt oder den falschen Datentypen beim Zuweisen verwendet. Die Fehler können auch dazu führen, dass der Code nicht ausgeführt wird. Der Compiler erkennt diese aber meistens. Semantische Fehler sind zum Beispiel, wenn eine Schleife nicht wie gewünscht abbricht und endlos weiter läuft. Außerdem ist auch ein abgefangener Fehler, der allerdings nicht wie gewünscht abgefangen wird ein sematischer Fehler. Oder wenn eine If-Anweisung nicht wie gewünscht verläuft. Semantische Fehler sind also Fehler, die nicht das erwatete Ergebnis liefern. Meistens lässt sich der Code ohne Fehler ausführen, dadurch ist es schwer diese Fehler zu erkennen.", "Syntaktisch: Verwendung einer Variable als Funktion, also zum Beispiel: int x = 1; int y = x(2);. Semantisch: Eine Funktion wurde falsche gecodet, weswegen sie das falsche Ergebnis ausgibt. Lexikalisch: Auf die Groß- und Kleinschreibung wird nicht geachtet.", "Lexikalischer Fehler ist statt 'if... else...' in Java 'if... then...' zu verwenden. Semantischer Fehler ist das Vergessen von Semikolon. Syntaktischer Fehler ist 'clas' statt 'class' schreiben."]
    },
    {
        "points": "3",
        "patterns": ["Gegeben ist die Klasse ClubMember, welche die Mitglieder eines Sportvereins repräsentiert. Die Klasse beinhaltet die Methoden public int getId() und public int getAge(), die die Mitgliedsnummer bzw. das Alter des Mitgliedes zurückgibt. Innerhalb der Vereinssoftware sind alle Mitglieder im folgenden Feld gespeichert: List<ClubMember> members. Hierbei ist List die entsprechende Datenstruktur aus dem Java Collections Framework. Nun soll eine Liste mit allen Mitgliedern über 60 erstellt werden. Was ist eine geeignete Implementierung der neuen Liste. Geben Sie den entsprechenden Typ aus dem Java Collections Framework an und begründen Ihre Entscheidung."],
        "responses": ["Eine geeignete Implementierung wäre eine ArrayList. Die Größe einer ArrayList ist nicht fest und kann somit durch das Einfügen von neuen Mitgliedern vergrößert werden. Außerdem können Mitglieder auch wieder entfernt werden, wenn sie die Mitgliedschaft beenden. Man kann auf die Mitglieder über ihren Index schnell zugreifen.", "Ich würde eine LinkedList verwenden. Man kann durch den Index auf die einzelnen Felder zugreifen und es gibt keine feste Größenbegrenzung wodurch man auch neue Mitgleider hinzufügen kann.", "Eine ArrayList wäre eine gute Wahl, da man die Mitglieder automatisch nach Alter ordnen werden und dann auch in dieser Reihenfolge auf sie zugreifen kann. Außerdem ist die Größe einer LinkedList nicht fest und kann somit verändert werden.", "Man kann eine Hash Map verwenden. Auf die Mitglieder kann man durch den Schlüssel zugreifen, sodass man sie schnell finden kann. Außerdem erlaubt eine Hashmap keine Duplikate, wird also ein Mitglied ausversehen zweimal zu der Liste hinzugefügt, so wird die Hashmap das Duplikat nicht hinzufügen. Die Größe ist nicht fest und ermöglicht das Hinzufügen von neuen Mitgleidern.", "Die Mitglieder können in einer ArrayList gespeichert werden.", "Man kann einen Array nutzen. Durch den Index kann man schnell auf die Mitgleider zugreifen. Man kann Elemente entfernen und wieder hinzufügen."]
    },
    {
        "points": "2",
        "patterns": ["Erläutere den Begriff Vererbung und wie er in der objektorientierten Programmierung verwendet wird."],
        "responses": ["Vererbung erlaubt das Wiederverwenden von Code. Durch vererben werden die Aufgaben spezialisiert. Die Oberklasse generalisiert und die Unterklasse speizialisiert die Aufgaben.", "Vererbung ist ein Konzept der objektorientierten Programmierung. Es erlaubt Klassen zu erstellen, die auf andere, vorher definierte, Klassen basieren. Die Unterklassen erben die Funktionalitäten der Oberklassen und spezifizieren diese. Dadurch kann der Code wiederverwendet werden.", "Bei der Vererbung ist eine neue Klasse die Erweiterung einer existierenden Klasse. 'Klasse A erbt von Klasse B' bedeutet, dass Klasse A die Funktionalität von B übernimmt und erweitert. Außerdem verhält sich Klasse A mindestens so wie Klasse B.", "Vererbung erlaubt es Eigenschaften und Methoden von bereits bestehenden Klassen zu übernehmen. Die Kindklasse erbt von der Elternklasse. Außerdem kann die Kindklasse noch weitere Funktionen definieren. Man kann so eine hierarchische Struktur erstellen und den Code wiederverwenden.", "Bei der Vererbung hat man Eltern- und Kindklassen.", "In der Vererbung erben die Elternklassen von den Kindklassen. Das heißt, Elternklassen können die Funktionen von Kindklassen verwenden und erweitern. Neue Funktionen kann man nicht implementieren."]
    },
    {
        "points": "4",
        "patterns": ["Was sind kontextfreie Grammatiken und wie kann man sie darstellen?"],
        "responses": ["Eine kontextfreie Grammatik ist eine formale Grammatik und entspricht der Typ-2-Grammatik der Chomsky-Hierarchie. Sie besteht aus einem Nichtterminalsymbol und danach können eine beliebig lange Folge von Nichtterminal oder Terminalsymbolen folgen. Sie wird durch ein vierer Tupel (V, A, P, S) dargestellt. V steht für eine nichtleere, endliche Menge von Nichtterminalsymbolen. A steht für eine nichtleere, endliche Menge von Terminalsymbolen. Für V geschnitten S gilt die leere Menge. P ist eine endliche Menge an Produktregeln. S ist das Startsymbol (S Element von V). Dabei gilt, dass die Grammatik die Vorraussetzungen einer Typ 1 Grammatik haben muss, das heißt, dass für jedes Paar (u,v) Element von P die Bedingung |u|<=|v| erfüllt ist. Außerdem gilt zusätzlich für das Paar (u,v), dass u ein Element von V ist.", "Eine kontextfreie Grammatik ist eine formale Grammatik und entspricht der Typ-2-Grammatik der Chomsky-Hierarchie. Sie besteht aus einem Nichtterminalsymbol und danach können eine beliebig lange Folge von Nichtterminal oder Terminalsymbolen folgen. Sie wird durch ein vierer Tupel (W, U, Z, M) dargestellt. W steht für eine nichtleere, endliche Menge von Nichtterminalsymbolen. U steht für eine nichtleere, endliche Menge von Terminalsymbolen. Für W geschnitten M gilt die leere Menge. Z ist eine endliche Menge an Produktregeln. M ist das Startsymbol (M Element von W). Dabei gilt, dass die Grammatik die Vorraussetzungen einer Typ 1 Grammatik haben muss, das heißt, dass für jedes Paar (u,v) Element von P die Bedingung |u|<=|v| erfüllt ist. Außerdem gilt zusätzlich für das Paar (u,w), dass u ein Element von W ist.", "Eine kontextfreie Grammatik ist eine formale Grammatik. Sie besteht aus einem Nichtterminalsymbol und danach können eine beliebig lange Folge von Nichtterminal oder Terminalsymbolen folgen. Sie wird durch ein vierer Tupel (V, A, P, S) dargestellt. V steht für eine nichtleere, endliche Menge von Nichtterminalsymbolen. A steht für eine nichtleere, endliche Menge von Terminalsymbolen. Für V geschnitten S gilt die leere Menge. P ist eine endliche Menge an Produktregeln. S ist das Startsymbol (S Element von V). Dabei müssen diese Vorraussetzungen gelten: für jedes Paar (u,v) Element von P ist die Bedingung |u|<=|v| erfüllt. Außerdem gilt zusätzlich für das Paar (u,v), dass u ein Element von V ist.", "Eine kontextfreie Grammatik ist eine formale Grammatik und entspricht der Typ-2-Grammatik der Chomsky-Hierarchie. Sie besteht aus einem Nichtterminalsymbol und danach können eine beliebig lange Folge von Nichtterminal oder Terminalsymbolen folgen.", "Eine kontextfreie Grammatik ist eine formale Grammatik und entspricht der Typ-3-Grammatik der Chomsky-Hierarchie. Die erzeugende Sparche heißt reguläre Sprache. Sie wird durch ein vierer Tupel (V, A, P, S) dargestellt. V steht für eine nichtleere, endliche Menge von Nichtterminalsymbolen. A steht für eine nichtleere, endliche Menge von Terminalsymbolen. Für V geschnitten S gilt die leere Menge. P ist eine endliche Menge an Produktregeln. S ist das Startsymbol (S Element von V). Dabei gilt, dass die Grammatik die Vorraussetzungen einer Typ 1 und Typ 2 Grammatik haben muss, das heißt, dass für jedes Paar (u,v) Element von P die Bedingung |u|<=|v| erfüllt ist und dass u ein Element von V ist. Zusätzlich muss v ist ein Element von A vereinigt AV erfüllt sein.", "Eine kontextfreie Grammatik ist eine formale Grammatik und entspricht der Typ-2-Grammatik der Chomsky-Hierarchie. Sie besteht aus einem Nichtterminalsymbol und danach können eine beliebig lange Folge von Nichtterminal oder Terminalsymbolen folgen. Sie wird durch ein dreier Tupel (V, A, P) dargestellt. V steht für eine nichtleere, endliche Menge von Nichtterminalsymbolen. A steht für eine nichtleere, endliche Menge von Terminalsymbolen. Für V geschnitten S gilt die leere Menge. P ist eine endliche Menge an Produktregeln. Dabei gilt, dass die Grammatik die Vorraussetzungen einer Typ 1 Grammatik haben muss, das heißt, dass für jedes Paar (u,v) Element von P die Bedingung |u|<=|v| erfüllt ist. Außerdem gilt zusätzlich für das Paar (u,v), dass u ein Element von V ist."]
    }]
}
